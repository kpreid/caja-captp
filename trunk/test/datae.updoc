# Copyright 2009 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

This file tests the Caja-CapTP implementation of Data-E serialization, which includes deAsJSONKit, deSubgraphKit, and makeSurgeon.

-------------------------------------------------------------------------------
The following code is boilerplate to load a Cajita module with collecting the return value. This code should be folded into some Cajita or EoJS library.

  ? def jsTools := <import:org.erights.eojs.jsTools>; null

  ? def exports; null
  
  ? def oldNewModuleHandler := cajitaPriv.getNewModuleHandler()
  > cajitaPriv.setNewModuleHandler(jsTools.asObject([
  >   "handle" => jsTools.asFunction(fn newModule {
  >     bind exports := newModule.instantiate(cajitaPriv.get___(), oldNewModuleHandler.getImports())
  >   })
  > ]))
  
  ? EoJS.asyncLoad("../src/datae.out.js")
  
  ? interp.waitAtTop(exports)

-------------------------------------------------------------------------------

  ? def deJSONTreeKit := exports["deJSONTreeKit"]
  # value: deJSONTreeKit
  
  ? def deSubgraphKit := exports["deSubgraphKit"]
  # value: deSubgraphKit
  
-------------------------------------------------------------------------------

Testing the builder of deJSONTreeKit.

  ? def b := deJSONTreeKit.makeBuilder()
  # value: <deJSONTreeKit builder>

--- Literals.
  
  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildLiteral("abcd"))
  # value: "abcd"
  
  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildLiteral(11234))
  # value: ["float64", 11234]

XXX review (format/interop): Do we want to support ints distinctly?
  
  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildLiteral(11234.5))
  # value: ["float64", 11234.5]
  
  No tests for characters since they are irrelevant to the JavaScript applicability right now. XXX review (format/interop): mismatch between JS and Data-E literal types -- interop vs. nativeness.

XXX review (format/interop): What to do about negative numbers? In Data-E they are represented as negation operations, but JS has no negate method. For now we permit them in literals.

--- Import.

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildImport("aardvark"))
  # value: ["import", "aardvark"]
  
--- Call.

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildCall(b.buildImport("a"), "b", [b.buildImport("c"), b.buildImport("d")]))
  # value: ["call", ["import", "a"], "b", [["import", "c"], ["import", "d"]]]

--- Define and ibid.

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildCall(def [t,id] := b.buildDefine(b.buildLiteral("Lorem")); t,
  >                         "add",
  >                         [b.buildIbid(id)]))
  # value: ["call", ["define", 0, "Lorem"], "add", [["ibid", 0]]]

Test that define increments a counter.

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildCall(def [t1,_] := b.buildDefine(b.buildLiteral("Lorem")); t1,
  >                         "add",
  >                         [def [t2,id] := b.buildDefine(b.buildLiteral("ipsum")); t2,
  >                          def [t3,_] := b.buildDefine(b.buildLiteral("dolor")); t3,
  >                          b.buildIbid(id)]))
  # value: ["call", ["define", 0, "Lorem"], "add", [["define", 1, "ipsum"], ["define", 2, "dolor"], ["ibid", 1]]]

--- Defrec.

Trivial circular structure: one call whose arg is itself

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(def prom := b.buildPromise()
  >             b.buildDefrec(prom+1,
  >                           b.buildCall(b.buildImport("makeFoo"),
  >                                       "run",
  >                                       [b.buildIbid(prom)])))
  # value: ["defrec", 0, ["call", ["import", "makeFoo"], "run", [["ibid", 0]]]]

-------------------------------------------------------------------------------

Testing the builder of deSubgraphKit.

  ? def env := jsTools.asObject([
  >   "x" => "aardvarks",
  >   "makeArray" => jsTools.asFunction(__makeList),
  > ]); null

  ? def b := deSubgraphKit.makeBuilder(env)
  # value: <deSubgraphKit builder>

--- Literals

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildLiteral(43))
  # value: 43
  
  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildLiteral("Lorem"))
  # value: "Lorem"

XXX if we introduce a big-integer type test it here

--- Import

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildImport("x"))
  # value: "aardvarks"

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildImport("yz"))
  # problem: Error: deSubgraphKit: Import not found: yz

--- Call

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildCall(b.buildImport("makeArray"), "call", ["bogus", b.buildImport("x"), b.buildLiteral("aardwolf")]))
  # value: ["aardvarks", "aardwolf"]

--- Define

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildCall(b.buildImport("makeArray"), "call",
  >                         [null,
  >                          def [t1,_] := b.buildDefine(b.buildLiteral("Lorem")); t1,
  >                          def [t2,id] := b.buildDefine(b.buildLiteral("ipsum")); t2,
  >                          def [t3,_] := b.buildDefine(b.buildLiteral("dolor")); t3,
  >                          b.buildIbid(id)]))
  # value: ["Lorem", "ipsum", "dolor", "ipsum"]

--- Defrec

Defrec is not supported yet because we haven't decided what to do about circular structure yet.

