# Copyright 2009 Kevin Reid, under the terms of the MIT X license
# found at http://www.opensource.org/licenses/mit-license.html ................

This file tests the Caja-CapTP implementation of Data-E serialization, which includes deAsJSONKit, deSubgraphKit, and makeSurgeon.

-------------------------------------------------------------------------------
The following code is boilerplate to load a Cajita module with collecting the return value. This code should be folded into some Cajita or EoJS library.

  ? def js := <import:org.erights.eojs.jsTools>; null

  ? def cajita := <import:org.erights.eojs.cajita>; null

  ? def exports; null
  
  ? def oldNewModuleHandler := cajitaPriv.getNewModuleHandler()
  > cajitaPriv.setNewModuleHandler(js.asObject([
  >   "handle" => js.asFunction(fn newModule {
  >     bind exports := newModule.instantiate(cajitaPriv.get___(), oldNewModuleHandler.getImports())
  >   })
  > ]))
  
  ? EoJS.asyncLoad("../src/datae.out.js")
  
  ? interp.waitAtTop(exports)

-------------------------------------------------------------------------------

  ? def deJSONTreeKit := exports["deJSONTreeKit"]
  # value: deJSONTreeKit
  
  ? def deSubgraphKit := exports["deSubgraphKit"]
  # value: deSubgraphKit
  
-------------------------------------------------------------------------------

Testing the builder of deJSONTreeKit.

  ? def b := deJSONTreeKit.makeBuilder()
  # value: <deJSONTreeKit builder>

--- Literals.
  
  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildLiteral("abcd"))
  # value: "abcd"
  
  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildLiteral(11234))
  # value: ["float64", 11234]

XXX review (format/interop): Do we want to support ints distinctly?
  
  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildLiteral(11234.5))
  # value: ["float64", 11234.5]
  
  No tests for characters since they are irrelevant to the JavaScript applicability right now. XXX review (format/interop): mismatch between JS and Data-E literal types -- interop vs. nativeness.

XXX review (format/interop): What to do about negative numbers? In Data-E they are represented as negation operations, but JS has no negate method. For now we permit them in literals.

Bogus literal:

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildLiteral(js.asObject([].asMap())))
  # problem: Error: deJSONTreeKit: This is not a literal: [object Object]


--- Import.

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildImport("aardvark"))
  # value: ["import", "aardvark"]
  
--- Call.

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildCall(b.buildImport("a"), "b", [b.buildImport("c"), b.buildImport("d")]))
  # value: ["call", ["import", "a"], "b", [["import", "c"], ["import", "d"]]]

--- Define and ibid.

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildCall(def [t,id] := b.buildDefine(b.buildLiteral("Lorem")); t,
  >                         "add",
  >                         [b.buildIbid(id)]))
  # value: ["call", ["define", 0, "Lorem"], "add", [["ibid", 0]]]

Test that define increments a counter.

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(b.buildCall(def [t1,_] := b.buildDefine(b.buildLiteral("Lorem")); t1,
  >                         "add",
  >                         [def [t2,id] := b.buildDefine(b.buildLiteral("ipsum")); t2,
  >                          def [t3,_] := b.buildDefine(b.buildLiteral("dolor")); t3,
  >                          b.buildIbid(id)]))
  # value: ["call", ["define", 0, "Lorem"], "add", [["define", 1, "ipsum"], ["define", 2, "dolor"], ["ibid", 1]]]

--- Defrec.

Trivial circular structure: one call whose arg is itself

  ? def b := deJSONTreeKit.makeBuilder()
  > b.buildRoot(def prom := b.buildPromise()
  >             b.buildDefrec(prom+1,
  >                           b.buildCall(b.buildImport("makeFoo"),
  >                                       "run",
  >                                       [b.buildIbid(prom)])))
  # value: ["defrec", 0, ["call", ["import", "makeFoo"], "run", [["ibid", 0]]]]

-------------------------------------------------------------------------------

Testing the builder of deSubgraphKit.

  ? def env := js.asObject([
  >   "x" => "aardvarks",
  >   "makeArray" => js.asFunction(__makeList),
  > ]); null

  ? def b := deSubgraphKit.makeBuilder(env)
  # value: <deSubgraphKit builder>

--- Literals

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildLiteral(43))
  # value: 43
  
  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildLiteral("Lorem"))
  # value: "Lorem"

XXX if we introduce a big-integer type test it here

--- Import

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildImport("x"))
  # value: "aardvarks"

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildImport("yz"))
  # problem: Error: deSubgraphKit: Import not found: yz

--- Call

The argument nodes are arbitrary, just to show that they are passed through.

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildCall(b.buildImport("makeArray"), "call", ["bogus", b.buildImport("x"), b.buildLiteral("aardwolf")]))
  # value: ["aardvarks", "aardwolf"]

--- Define

  ? def b := deSubgraphKit.makeBuilder(env)
  > b.buildRoot(b.buildCall(b.buildImport("makeArray"), "call",
  >                         [null,
  >                          def [t1,_] := b.buildDefine(b.buildLiteral("Lorem")); t1,
  >                          def [t2,id] := b.buildDefine(b.buildLiteral("ipsum")); t2,
  >                          def [t3,_] := b.buildDefine(b.buildLiteral("dolor")); t3,
  >                          b.buildIbid(id)]))
  # value: ["Lorem", "ipsum", "dolor", "ipsum"]

--- Defrec

Defrec is not supported yet because we haven't decided what to do about circular structure yet.

-------------------------------------------------------------------------------

Given that the builders for each kit have been tested independently, we now test the recognizers by connecting them to the builders. First, some test infrastructure...

  ? def uncallExample {}  # this needs to be not-a-literal
  > 
  > def failingUncaller := js.asObject([
  >   "optUncall" => js.asFunction(def _(obj) {
  >     return js.null()
  >   }),
  > ])
  > def testUncaller := js.asObject([
  >   "optUncall" => js.asFunction(def _(obj) {
  >     if (obj == uncallExample) {
  >       return [1, "run", ["aardvarks", 32.5]]
  >     } else if (obj == "aardvarks") {
  >       return ["FAIL", "run", ["shouldn't get my hands on an exit"]]
  >     } else {
  >       return js.null()
  >     }
  >   }),
  > ])
  > 
  > def testUnenv := cajita.newTable(false)
  > testUnenv.set("aardvarks", "x")
  > null

deSubgraphKit recognizer

  ? def r := deSubgraphKit.makeRecognizer([failingUncaller, testUncaller], testUnenv)
  # value: <deSubgraphKit recognizer>

There are four cases when an object is serialized; they are considered in this order.

1. It is a graph exit: builder.buildImport is used.

  ? r.recognize("aardvarks", deJSONTreeKit.makeBuilder())
  # value: ["import", "x"]

2. It is a literal: builder.buildLiteral is used.

  ? r.recognize(1, deJSONTreeKit.makeBuilder())
  # value: ["float64", 1]

  ? r.recognize("foo", deJSONTreeKit.makeBuilder())
  # value: "foo"

3. It is a composite object; each uncaller is applied to it in order, and the first success is passed to builder.buildCall. (The recipient and arguments here are chosen to exercise that they are in fact recursively processed.)

  ? r.recognize(uncallExample, deJSONTreeKit.makeBuilder())
  # value: ["call", ["float64", 1], "run", [["import", "x"], ["float64", 32.5]]]

4. It is not serializable; an error is produced.

  ? r.recognize(def randomObj {}, deJSONTreeKit.makeBuilder())
  # problem: Error: deSubgraphKit: can't uneval: <E object randomObj>